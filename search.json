[
  {
    "objectID": "seminario3.html",
    "href": "seminario3.html",
    "title": "Introdução",
    "section": "",
    "text": "Os seminários da disciplina consistem em uma apresentação coletiva (da turma) de um artigo mais recente sobre tópicos diretamente relacionados ao conteúdo visto em sala. A ideia é que a turma como um todo estude os artigos mais recentes da área e discuta esses trabalhos em sala. Em cada sessão, discutimos dois artigos recentes relacionados aos tópicos abordados nas aulas teóricas.\nPara isso, adotamos um formato adaptado da proposta apresentada pelos Profs. Alec Jacobson e Colin Raffel, ambos da Universidade de Toronto (Canadá) – veja aqui a proposta original. A proposta consiste em fazer uma encenação de papéis (role play) científicos para a apresentação do seminário. Nessa proposta, cada grupo cumprirá um papel na apresentação. Ao final, uma apresentação em formato de slides e um documento textual são produzidos. A apresentação é usada em sala de aula para fomentar as discussões, enquanto o documento fornece uma descrição textual das impressões da turma com a intenção de descrever o tema do artigo para um público amplo interessado em aprendizado de máquina e mineração de dados.\nSão apresentados a seguir os artigos discutidos no semestre 2025/1, com os respectivos links para os slides e documentos textuais apresentando os artigos.\n\n\n\nModeling Match Performance in Elite Volleyball Players: Importance of Jump Load and Strength Training Characteristics\nAutores: A.-W. de Leeuw, R. van Baar, A. Knobbe, and S. van der Zwaard. 2022\nDOI: 10.3390/s22207996\n\n\n\n\n\nExceptional Subitizing Patterns: Exploring Mathematical Abilities of Finnish Primary School Children with Piecewise Linear Regression\nAutores: R. M. Schouten, W. Duivesteijn, P. Räsänen, J. M. Paul, and M. Pechenizkiy. 2024\nDOI: 10.1007/978-3-031-70381-2_5"
  },
  {
    "objectID": "seminario3.html#artigo-5seminario_art5",
    "href": "seminario3.html#artigo-5seminario_art5",
    "title": "Introdução",
    "section": "",
    "text": "Modeling Match Performance in Elite Volleyball Players: Importance of Jump Load and Strength Training Characteristics\nAutores: A.-W. de Leeuw, R. van Baar, A. Knobbe, and S. van der Zwaard. 2022\nDOI: 10.3390/s22207996"
  },
  {
    "objectID": "seminario3.html#artigo-6seminario_art6",
    "href": "seminario3.html#artigo-6seminario_art6",
    "title": "Introdução",
    "section": "",
    "text": "Exceptional Subitizing Patterns: Exploring Mathematical Abilities of Finnish Primary School Children with Piecewise Linear Regression\nAutores: R. M. Schouten, W. Duivesteijn, P. Räsänen, J. M. Paul, and M. Pechenizkiy. 2024\nDOI: 10.1007/978-3-031-70381-2_5"
  },
  {
    "objectID": "seminario1.html",
    "href": "seminario1.html",
    "title": "Introdução",
    "section": "",
    "text": "Os seminários da disciplina consistem em uma apresentação coletiva (da turma) de um artigo mais recente sobre tópicos diretamente relacionados ao conteúdo visto em sala. A ideia é que a turma como um todo estude os artigos mais recentes da área e discuta esses trabalhos em sala. Em cada sessão, discutimos dois artigos recentes relacionados aos tópicos abordados nas aulas teóricas.\nPara isso, adotamos um formato adaptado da proposta apresentada pelos Profs. Alec Jacobson e Colin Raffel, ambos da Universidade de Toronto (Canadá) – veja aqui a proposta original. A proposta consiste em fazer uma encenação de papéis (role play) científicos para a apresentação do seminário. Nessa proposta, cada grupo cumprirá um papel na apresentação. Ao final, uma apresentação em formato de slides e um documento textual são produzidos. A apresentação é usada em sala de aula para fomentar as discussões, enquanto o documento fornece uma descrição textual das impressões da turma com a intenção de descrever o tema do artigo para um público amplo interessado em aprendizado de máquina e mineração de dados.\nSão apresentados a seguir os artigos discutidos no semestre 2025/1, com os respectivos links para os slides e documentos textuais apresentando os artigos.\n\n\n\nDifferentiable Pattern Set Mining\nAutores: J. Fischer; J. Vreeken. 2021\nDOI: 10.1145/3447548.3467348\n\n\n\n\n\nDiscovering frequent parallel episodes in complex event sequences by counting distinct occurrences\nAutores: O. Ouarem; F. Nouioua; P. Fournier-Viger\nDOI: 10.1007/s10489-023-05187-y"
  },
  {
    "objectID": "seminario1.html#artigo-1seminario_art1",
    "href": "seminario1.html#artigo-1seminario_art1",
    "title": "Introdução",
    "section": "",
    "text": "Differentiable Pattern Set Mining\nAutores: J. Fischer; J. Vreeken. 2021\nDOI: 10.1145/3447548.3467348"
  },
  {
    "objectID": "seminario1.html#artigo-2seminario_art2",
    "href": "seminario1.html#artigo-2seminario_art2",
    "title": "Introdução",
    "section": "",
    "text": "Discovering frequent parallel episodes in complex event sequences by counting distinct occurrences\nAutores: O. Ouarem; F. Nouioua; P. Fournier-Viger\nDOI: 10.1007/s10489-023-05187-y"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aprendizado Descritivo",
    "section": "",
    "text": "Aprendizado Descritivo (2025/1) — DCC/UFMG   Prof. Renato Vimieiro \n\nEssa disciplina é ofertada no Programa de Pós-Graduação em Ciência da Computação da Universidade Federal de Minas Gerais. Ela tem como objetivo apresentar técnicas avançadas para identificação de padrões descritivos em bases de dados. A(o) aluna(o) terá contato com técnicas para aprendizado de padrões não-supervisionados e supervisionados. Serão discutidas as dificuldades computacionais da busca por tais padrões, bem como sua utilidade para análise exploratória de dados.\nOs tópicos abordados na disciplina são:\n\nDiferenças entre aprendizado descritivo e preditivo.\nAprendizado descritivo não-supervisionado.\nAprendizado descritivo supervisionado.\nRepresentações condensadas.\nMétricas de qualidade de padrões descritivos.\nAlgoritmos de aprendizado de padrões descritivos supervisionados e não-supervisionados.\nEstudos de casos e aplicações em problemas reais.\n\nOs tópicos são apresentados através de aulas expositivas sobre o assunto, leitura e apresentação de seminários sobre artigos recentes na literatura, e projetos de aplicação dos métodos estudados para extração de conhecimento de bases de dados.\nUtilize o menu acima ou o link a seguir para visualizar o conteúdo produzido nos seminários e projetos desenvolvidos pelos alunos na oferta de 2025/1.\n\nSeminários: Padrões frequentes; Descoberta de subgrupos; Aplicações\n\nUma página similar também foi construída para ofertas anteriores do curso. Os links estão a seguir:\n\n2024/1."
  },
  {
    "objectID": "projetos.html",
    "href": "projetos.html",
    "title": "Projetos apresentados pelos alunos na disciplina Aprendizado Descritivo 2025/1",
    "section": "",
    "text": "O projeto da disciplina de Aprendizado Descritivo é uma atividade avaliativa conduzida pelos alunos da turma divididos em grupos. O objetivo do projeto é analisar um conjunto de dados escolhido pelo grupo, usando as técnicas vistas em sala de aula (aulas expositivas e seminários). Os links a seguir redirecionam para os repositórios dos respectivos projetos. É importante ressaltar que, embora tenha sido exigido rigor científico na execução do projeto, os resultados cumprem apenas um papel didático."
  },
  {
    "objectID": "seminario1/artigo1.html",
    "href": "seminario1/artigo1.html",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "Mineração de padrões é uma área de Aprendizado Descritivo que objetiva encontrar informações interpretáveis de grandes bancos de dados. Tal objetivo é alcançado por meio da mineração de “padrões” ou “regras” que definem conjuntos relevantes, seja em frequência ou em importância.\nAs aplicações de mineração de padrões são variadas, desde ciências naturais como Biologia e Química, estudos estatísticos e matemáticos e análises societais e comportamentais.\nInfelizmente, os algoritmos para mineração de padrões são extremamente custosos, sendo duplamente exponencial no número de atributos. Além disso, eles sofrem de redundância nas respostas, muitas vezes repetindo padrões similares e de relevância das respostas, sofrendo com overfitting ou underfitting.\n\n\n\nPara resolver a problemática acima, o algoritmo introduz o BinaPs, uma solução que vê o problema por meio da lente de aprendizado de máquina ao invés de construção de conjuntos. Para entender melhor as duas perspectivas, considere as diferenças principais do BinaPs para algoritmos tradicionais:\n\nApriori, Eclat, FP-Growth:\n\nPadrões escolhidos por frequência\nPadrões redundantes encontrados\nApenas otimizados por heurísticas\nCalculado na CPU\n\nBinaPs:\n\nFunções diferenciáveis para descoberta de padrões\nPadrões menos redundantes\nGPU para cálculos\nSignificativamente mais escalável\nOtimizável por parâmetros de entrada como learning rate\n\n\n\n\nInspirado por decoders e encoders, o algoritmo tem como objetivo pegar os atributos de um item, codificar eles em o mesmo número ou menos de neurônios no processo e retornar para o número inicial como representado pela Figura 1.\n\n\n\nFigura 1: Encoder e Decoder\n\n\n\n\n\n\nO BinaPs contém algumas otimizações e considerações quando considerado com outras rede neurais, dentre elas:\n\nOs neurônios e pesos finais são binários \\(\\{0, 1\\}\\)\nViês é usado para evitar overfitting\nNormalização da função de perda para evitar saídas de apenas \\(\\{1\\}\\) ou \\(\\{0\\}\\) em bases densas e esparsas.\nGated Straight-Through Estimator para não penalizar os neurônios desligados\n\nApós essas mudanças, o algoritmo funciona como descrito por esta imagem (Figura 2 do artigo):\n\n\n\nFigura 2: Funcionamento do BinaPs\n\n\n\n\n\n\n\n\n\n\nO BinaPs foi comparado com três outros competidores na área de mineração de dados: Asso, Slim e Desc, que usam matrizes booleanas, mineração de conjuntos por MDL e maximum entropy modeling respectivamente. Os experimentos foram divididos em duas categorias: sintéticos e reais.\n\n\nDados sintéticos foram escolhidos pois é possível inserir ou estudar padrões reais nos dados previamente, podendo assim comparar os resultados dos algoritmos com o “ground truth”, ou seja, o que assumimos ser a verdade.\nPara medir a performance dos algoritmos foi usado a F1-score, uma medida calculada pela média harmonica do precision e do recall, comumente usada em aprendizado de máquina para avaliar a performance de modelos.\n\n\n\n\n\nFigura 3: Estatísticas BinaPs, Asso, Slim e Desc: Features\n\n\n\n\n\n\n\n(a) F1-Score\n\n\n\n\n\n\n\n\n\n\n\n(b) Time in Seconds\n\n\n\n\n\n\n\n\n\n\n\nCom um número crescente de features (atributos), o BinaPs se mostra mais preciso (Figura 3 (a)) e menos custoso (Figura 3 (b)) em tempo que os outros três, com o Asso se assemelhando a ele em resultados, mas não em performance, eventualmente não sendo capaz de rodar datasets maiores.\n\n\n\nMuitas vezes dados reais possuem ruídos, seja de medidas errôneas, problemas no dataset ou imprevisibilidade dos dados. Para testar se os algoritmos são resistentes a tais cenários foram inseridos quantidades crescentes de ruídos nos databases testados com os seguintes resultados:\n\n\n\nFigura 4: Estatísticas BinaPs, Asso, Slim e Desc: Ruídos\n\n\n\n\n\n\n\n\n\n\nAo analisar os gráficos, ambos o BinaPs e o Asso são resistentes a ruídos em ambos F1-score (?@fig-F1-Score-noise) e tempo de execução (?@fig-time-in-seconds-noise). Já ambos Slim e Desc são afetados por ruídos no F1-score (?@fig-F1-Score-noise) e o Slim em tempo de execução (?@fig-time-in-seconds-noise) também.\n\n\n\n\n\n\nFigura 5: F1-Score \\(\\times\\) Samples\n\n\n\n\n\n\nPara testar a capacidade do BinaPs de operar com poucos samples, também foi feito testes com quantidades crescentes de dados para ver sua performance.\nMesmo com um número bem reduzido de samples o BinaPs foi capaz de conseguir uma pontuação boa (Figura 5), melhorando marginalmente com mais samples até estabilizar perto do final do gráfico.\n\n\n\n\nForam usados 5 bases de dados reais para o comparativo entre os algoritmos:\n\nDNA: Dados de amplificação de DNA\nAccidents: Dados de acidentes belgas\nInstacart: Dados de compras de supermercado online\nKorsarak: Dados de cliques em um site de notícias hungaro\nGenomes: Dados de indivíduos no projeto 1000 genomes\n\n\n\nAo contrário dos dados sintéticos, não temos como saber quais padrões são “corretos” ou “incorretos”. Dessa forma, a análise é mais subjetiva. Primeiro comparamos o número de padrões encontrados (Tabela 3 (b)) nos 5 bancos de dados (Tabela 3) e o tempo de execução de cada algoritmo (Tabela 3 (c)).\n\nTabela 1a: \\(\\#\\ Patterns\\)\n\n\n\n\nTabela 1: Número de padrões encontrados pelos algoritmos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(Dataset\\)\n\\(\\#\\ rows\\)\n\\(\\#\\ cols\\)\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\nDNA\n\\(2458\\)\n\\(391\\)\n\\(134\\)\n\\(131\\)\n\\(345\\)\n\\(281\\)\n\n\nAccidents\n\\(340183\\)\n\\(468\\)\n\\(133\\)\n\\(78\\)\n\\(215\\)\n\\(12261\\)\n\n\nInstacart\n\\(2704831\\)\n\\(1235\\)\n\\(n/a\\)\n\\(328\\)\n\\(712\\)\n\\(8119\\)\n\n\nKosarak\n\\(990002\\)\n\\(41270\\)\n\\(n/a\\)\n\\(302\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\nGenomes\n\\(2504\\)\n\\(226623\\)\n\\(n/a\\)\n\\(42\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\n\n\n\n\n\nTabela 1b: \\(Runtime\\)\n\n\n\n\nTabela 2: Comparativo de tempo entre os algoritmos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(Dataset\\)\n\\(\\#\\ rows\\)\n\\(\\#\\ cols\\)\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\nDNA\n\\(2458\\)\n\\(391\\)\n\\(4 m\\)\n\\(26 s\\)\n\\(20 s\\)\n\\(2 s\\)\n\n\nAccidents\n\\(340183\\)\n\\(468\\)\n\\(12 h\\)\n\\(6 m\\)\n\\(14 m\\)\n\\(21 h\\)\n\n\nInstacart\n\\(2704831\\)\n\\(1235\\)\n\\(\\infty\\)\n\\(44 m\\)\n\\(25 m\\)\n\\(8 h\\)\n\n\nKosarak\n\\(990002\\)\n\\(41270\\)\n\\(\\infty\\)\n\\(5 h\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\nGenomes\n\\(2504\\)\n\\(226623\\)\n\\(\\infty\\)\n\\(9 m\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\n\n\n\n\n\n\n\n\nTabela 3: Tabela comparativa dos datasets\n\n\n\n\n\n\n\n(a) Linhas e colunas dos datasets\n\n\n\n\n\n\\(Dataset\\)\n\\(\\#\\ rows\\)\n\\(\\#\\ cols\\)\n\n\n\n\nDNA\n\\(2458\\)\n\\(391\\)\n\n\nAccidents\n\\(340183\\)\n\\(468\\)\n\n\nInstacart\n\\(2704831\\)\n\\(1235\\)\n\n\nKosarak\n\\(990002\\)\n\\(41270\\)\n\n\nGenomes\n\\(2504\\)\n\\(226623\\)\n\n\n\n\n\n\n\n\n\n\n\n(b) Número de padrões encontrados pelos algoritmos\n\n\n\n\n\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\n\\(134\\)\n\\(131\\)\n\\(345\\)\n\\(281\\)\n\n\n\\(133\\)\n\\(78\\)\n\\(215\\)\n\\(12261\\)\n\n\n\\(n/a\\)\n\\(328\\)\n\\(712\\)\n\\(8119\\)\n\n\n\\(n/a\\)\n\\(302\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\n\\(n/a\\)\n\\(42\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\n\n\n\n\n\n\n\n\n\n(c) Comparativo de tempo entre os algoritmos\n\n\n\n\n\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\n\\(4 m\\)\n\\(26 s\\)\n\\(20 s\\)\n\\(2 s\\)\n\n\n\\(12 h\\)\n\\(6 m\\)\n\\(14 m\\)\n\\(21 h\\)\n\n\n\\(\\infty\\)\n\\(44 m\\)\n\\(25 m\\)\n\\(8 h\\)\n\n\n\\(\\infty\\)\n\\(5 h\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\n\\(\\infty\\)\n\\(9 m\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\n\n\n\n\n\n\n\n\n\n\nEm alguns casos, os outros algoritmos não conseguiram rodar em até 3 dias ou dentre 256GB de RAM. Tais cenários foram marcados com n/a ou infinito ({Tabela 2}).\nO BinaPs retornou resultados menos redundantes, facilitando interpretabilidade. Além disso, foram notados algumas falhas em outros algoritmos, dentre eles:\n\nAsso não conseguiu escalar bem\nSlim encontrou milhares de resultados redundantes\nDesc sofre de underfitting e só retornou padrões de tamanho 2 no Instacart.\n\n\n\n\nFoi feita uma análise quantitativa em 3 dos bancos de dados listados acima. Duas comparativas (DNA, Instacart) e uma individual.\nDNA: BinaPs e Asso encontraram blocos de DNA e conjuntos desses blocos como estruturas, representando elementos biologicamente relevantes. Slim começa a encontrar blocos, mas faz um overfitting para padrões grandes demais que acontecem raramente e não tem estrutura evidente de blocos. Desc encontra padrões pequenos apenas graças a um underfitting.\nInstacart: BinaPs encontra padrões grandes com combinações arbitrárias como um conjunto de 12 frutas comprados de formas diferentes. O Slim quebra este conjunto em milhares de padrões menores. Desc faz underfitting novamente, encontrando padrões de tamanho 2 apenas. Além disso, o BinaPs também encontrou padrões pequenos que se assemelham à lista de ingredientes de pratos culinários, mostrando relevância novamente.\nGenomes: De acordo com os autores, esta seção obteve os resultados mais promissores, sendo um motivador principal para o estudo.\nFoi possível encontrar padrões antes conhecidos de genes relacionados, como os NUCB2 e ABCC8 relacionados à diabetes tipo 2 e pressão alta em populações japonesas. Porém, muitas vezes esses grupos conhecidos estavam adjuntos a outros elementos, como o NCR3LG1 e ROMO1. Isso demonstra a possibilidade do uso do algoritmo para estabelecer relações novas que podem ser estudadas no futuro.\nOutro exemplo foi o dos genes SF3A1, RRP7A e Z82190 onde os dois primeiros codificam proteínas que são parte do ribossomo (que por sua conta é a fábrica de proteínas da célula), já o terceiro não é caracterizado. O padrão destes juntos é uma dica que pode guiar estudos futuros nessa área.\nPor final, ao analisar padrões de variantes entre alelos, o BinaPs sugere que variantes raras normalmente acompanhadas de comuns podem acontecer de um para o outro “\\(0 \\mid 1\\)” como na literatura, mas muitas vezes também acontece em “1 ”, ou seja, os raros no alelo que antes havia comuns e vice-versa. Os autores não sabem se isso têm significado biológico, sugerindo que isso seja analisado por profissionais da área.\n\n\n\n\n\nO artigo nos entrega um Link para o repositório. Para rodar o BinaPs em uma máquina comum é necessário:\n\n\n\nBaixar e descompactar os arquivos\nInstalar as dependências (Pytorch, Scipy, Pandas, Numpy, R)\nAlterar arquivo genSynth.sh para parâmetros de uma máquina convencional (8 a 32GB de RAM)\nExecutar ./genSynth.sh\n\nO resultado é um arquivo .dat com os dados em formato de matriz binária esparsa. Ou seja, para cada linha, os elementos da linha são os indices das posições com valor 1 na matriz original.\n\n\nPara executar basta chamar python main.py --input &lt;arquivo.dat&gt; --batch_size &lt;32 ou 64&gt; que pode também ser adjunto dos parâmetros apresentados na Tabela 4.\n\n\n\nTabela 4: Parâmetros do BinaPs\n\n\n\n\n\n\n\n\n\n\n\nParâmetro\nTipo\nValor padrão\nDescrição\n\n\n\n\n--save_model\nbool\n\\(False\\)\nSe ativado, salva o modelo treinado para disco\n\n\n--gamma\nfloat\n\\(0.1\\)\nFator de decaimento do learning rate (usado no agendador de LR)\n\n\n--lr\nfloat\n\\(0.01\\)\nTaxa de aprendizado (learning rate)\n\n\n--train_set_size\nfloat\n\\(0.9\\)\nProporção dos dados usada para treinamento\n\n\n--weight_decay\nfloat\n\\(0.0\\)\nFator de penalização L2 (regularização dos pesos)\n\n\n--batch_size\nint\n\\(64\\)\nTamanho do batch para treinamento\n\n\n--epochs\nint\n\\(10\\)\nNúmero de épocas de treinamento\n\n\n--hidden_dim\nint\n\\(-1\\)\nNúmero de neurônios ocultos (usa #features se -1)\n\n\n--log_interval\nint\n\\(10\\)\nIntervalo (em batches) para exibir logs de treino\n\n\n--seed\nint\n\\(1\\)\nSemente para reprodutibilidade (random seed)\n\n\n--test_batch_size\nint\n\\(64\\)\nTamanho do batch para teste\n\n\n--thread_num\nint\n\\(16\\)\nNúmero de threads a serem usadas no treinamento\n\n\n--input (-i)\nstr\nObrigatório\nCaminho para o arquivo de entrada (dados usados para treino e teste)\n\n\n\n\n\n\n\n\n\nApós o treinamento marcado pelas “Epoch” temos alguns dados como a “Average loss” e a “Accuracy” seguido dos padrões dispostos na Figura 6.\n\n\n\nFigura 6: Resultado da execução do BinaPs\n\n\n\n\n\n\nCada linha dos padrões mostra um padrão que foi reconstruído, como por exemplo o \\([45, 46, 47, 48, 49]\\) seguido de dois números: O primeiro o número de amostras que ativaram todos os bits e o segundo amostras que ativaram metade dos bits do padrão. Ou seja, \\(4404\\) vezes os bits \\(45\\) a \\(49\\) foram completamente ativados e \\(4425\\) vezes parcialmente ativados (metade).\nConclusão: O padrão \\([45-49]\\) é altamente confiável pois aparece em mais de 99% das vezes que é parcialmente ativado, indicando forte consistência local nos dados.\n\n\n\n\n\n\n\nO método do BinaPs é significativamente mais interpretável que outras soluções usando inteligência artificial ou caixas-pretas. Tal transparência entrega um grau de confiança maior aos resultados e pode levar a estudos e entendimentos novos relacionados à area investigada.\nAlém disso, como o processo é transparente, ele se torna mais fácil de ser ajustado por profissionais para evitar vieses indesejados como os de cor, gênero, raça, classe e outros.\n\n\n\n\nSimilarmente a outros métodos de mineração de padrões, os usos são bem vastos, mas dessa vez eles são beneficiados também pela transparência. Aqui estão alguns deles:\n\nSaúde\n\nEstudo de biomarcadores relevantes para diagnósticos\nDetecção de padrões comuns à doenças como sintomas\n\nCidades inteligentes\n\nAnálise de padrões de tráfego para otimização do transporte\nMineração de padrões no uso de serviços públicos\n\nEducação\n\nAnálise de trajetórias acadêmicas para politicas de incentivo\nEstudo de consumo de cursos para personalização de trilhas\n\nComércio\n\nPadrões de compras para sistemas de recomendação\nPerfis de consumidores para marketing personalizado\n\nGovernos e Organizações\n\nDetecção de padrões de fraude em transações como as bancárias\nEstudo de padrões comportamentais para prevenção de crimes\n\n\n\n\n\nO BinaPs é uma ferramenta. Da mesma forma que é necessário cuidado ao usar um martelo, é importante saber os riscos que tomamos ao usar uma ferramenta dessas para evitar problemas. Um dos maiores riscos são os de dados enviesados.\nGrande porção dos dados usados são daqueles que mais coletam dados, que tendem a ser países de primeiro mundo nas classes media e alta. Além disso, muitos dados são enviesados por cor, raça, gênero e outros fatores que não devem serem analisados como causalidade por motivos éticos.\nExemplos de dados enviesados incluem a ferramenta de triagem de currículos da Amazon, que aprendeu e manteve o preconceito de gênero que estava presente antes de sua implementação, o que desfavoreceu o gênero feminino.\nAlém disso, há áreas de implementação que não podem ter vieses como por exemplo:\n\nConcessão de crédito\n\nDiscriminação, Desinformação, Privacidade, Over-Marketing\n\nPrecificação de seguros e planos de saúde\n\nDiferenciação de grupos por fatores pessoais, étnicos, etários ou de doenças.\n\n\nEm ambos os casos, são necessárias políticas como a LGPD para garantir a anonimização dos dados e a publicação de métodos e entradas utilizados para que especialistas possam discutir as questões éticas do uso dos dados específicos utilizados.\n\n\n\nO BinaPs é um algoritmo de mineração de padrões inovador, com características transparentes e eficientes em relação à competição. Seu código é aberto e bem explicado com um gerador de dados sintéticos incluso e alguns estudos preliminares de áreas que podem beneficiar do seu uso. Se for usado como uma ferramenta de forma responsável, ele pode ser um pioneiro em estudos, análises e sumarizações de dados massivos.\n\n\n\n\nTítulo: Differentiable Pattern Set Mining\nArtigo (Fischer e Vreeken (2021))\n\nPDF\nApresentação dos Autores\n\nApresentação\n\nPDF"
  },
  {
    "objectID": "seminario1/artigo1.html#o-que-é-mineração-de-padrões",
    "href": "seminario1/artigo1.html#o-que-é-mineração-de-padrões",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "Mineração de padrões é uma área de Aprendizado Descritivo que objetiva encontrar informações interpretáveis de grandes bancos de dados. Tal objetivo é alcançado por meio da mineração de “padrões” ou “regras” que definem conjuntos relevantes, seja em frequência ou em importância.\nAs aplicações de mineração de padrões são variadas, desde ciências naturais como Biologia e Química, estudos estatísticos e matemáticos e análises societais e comportamentais.\nInfelizmente, os algoritmos para mineração de padrões são extremamente custosos, sendo duplamente exponencial no número de atributos. Além disso, eles sofrem de redundância nas respostas, muitas vezes repetindo padrões similares e de relevância das respostas, sofrendo com overfitting ou underfitting."
  },
  {
    "objectID": "seminario1/artigo1.html#binaps",
    "href": "seminario1/artigo1.html#binaps",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "Para resolver a problemática acima, o algoritmo introduz o BinaPs, uma solução que vê o problema por meio da lente de aprendizado de máquina ao invés de construção de conjuntos. Para entender melhor as duas perspectivas, considere as diferenças principais do BinaPs para algoritmos tradicionais:\n\nApriori, Eclat, FP-Growth:\n\nPadrões escolhidos por frequência\nPadrões redundantes encontrados\nApenas otimizados por heurísticas\nCalculado na CPU\n\nBinaPs:\n\nFunções diferenciáveis para descoberta de padrões\nPadrões menos redundantes\nGPU para cálculos\nSignificativamente mais escalável\nOtimizável por parâmetros de entrada como learning rate\n\n\n\n\nInspirado por decoders e encoders, o algoritmo tem como objetivo pegar os atributos de um item, codificar eles em o mesmo número ou menos de neurônios no processo e retornar para o número inicial como representado pela Figura 1.\n\n\n\nFigura 1: Encoder e Decoder\n\n\n\n\n\n\nO BinaPs contém algumas otimizações e considerações quando considerado com outras rede neurais, dentre elas:\n\nOs neurônios e pesos finais são binários \\(\\{0, 1\\}\\)\nViês é usado para evitar overfitting\nNormalização da função de perda para evitar saídas de apenas \\(\\{1\\}\\) ou \\(\\{0\\}\\) em bases densas e esparsas.\nGated Straight-Through Estimator para não penalizar os neurônios desligados\n\nApós essas mudanças, o algoritmo funciona como descrito por esta imagem (Figura 2 do artigo):\n\n\n\nFigura 2: Funcionamento do BinaPs"
  },
  {
    "objectID": "seminario1/artigo1.html#experimentos",
    "href": "seminario1/artigo1.html#experimentos",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "O BinaPs foi comparado com três outros competidores na área de mineração de dados: Asso, Slim e Desc, que usam matrizes booleanas, mineração de conjuntos por MDL e maximum entropy modeling respectivamente. Os experimentos foram divididos em duas categorias: sintéticos e reais.\n\n\nDados sintéticos foram escolhidos pois é possível inserir ou estudar padrões reais nos dados previamente, podendo assim comparar os resultados dos algoritmos com o “ground truth”, ou seja, o que assumimos ser a verdade.\nPara medir a performance dos algoritmos foi usado a F1-score, uma medida calculada pela média harmonica do precision e do recall, comumente usada em aprendizado de máquina para avaliar a performance de modelos.\n\n\n\n\n\nFigura 3: Estatísticas BinaPs, Asso, Slim e Desc: Features\n\n\n\n\n\n\n\n(a) F1-Score\n\n\n\n\n\n\n\n\n\n\n\n(b) Time in Seconds\n\n\n\n\n\n\n\n\n\n\n\nCom um número crescente de features (atributos), o BinaPs se mostra mais preciso (Figura 3 (a)) e menos custoso (Figura 3 (b)) em tempo que os outros três, com o Asso se assemelhando a ele em resultados, mas não em performance, eventualmente não sendo capaz de rodar datasets maiores.\n\n\n\nMuitas vezes dados reais possuem ruídos, seja de medidas errôneas, problemas no dataset ou imprevisibilidade dos dados. Para testar se os algoritmos são resistentes a tais cenários foram inseridos quantidades crescentes de ruídos nos databases testados com os seguintes resultados:\n\n\n\nFigura 4: Estatísticas BinaPs, Asso, Slim e Desc: Ruídos\n\n\n\n\n\n\n\n\n\n\nAo analisar os gráficos, ambos o BinaPs e o Asso são resistentes a ruídos em ambos F1-score (?@fig-F1-Score-noise) e tempo de execução (?@fig-time-in-seconds-noise). Já ambos Slim e Desc são afetados por ruídos no F1-score (?@fig-F1-Score-noise) e o Slim em tempo de execução (?@fig-time-in-seconds-noise) também.\n\n\n\n\n\n\nFigura 5: F1-Score \\(\\times\\) Samples\n\n\n\n\n\n\nPara testar a capacidade do BinaPs de operar com poucos samples, também foi feito testes com quantidades crescentes de dados para ver sua performance.\nMesmo com um número bem reduzido de samples o BinaPs foi capaz de conseguir uma pontuação boa (Figura 5), melhorando marginalmente com mais samples até estabilizar perto do final do gráfico.\n\n\n\n\nForam usados 5 bases de dados reais para o comparativo entre os algoritmos:\n\nDNA: Dados de amplificação de DNA\nAccidents: Dados de acidentes belgas\nInstacart: Dados de compras de supermercado online\nKorsarak: Dados de cliques em um site de notícias hungaro\nGenomes: Dados de indivíduos no projeto 1000 genomes\n\n\n\nAo contrário dos dados sintéticos, não temos como saber quais padrões são “corretos” ou “incorretos”. Dessa forma, a análise é mais subjetiva. Primeiro comparamos o número de padrões encontrados (Tabela 3 (b)) nos 5 bancos de dados (Tabela 3) e o tempo de execução de cada algoritmo (Tabela 3 (c)).\n\nTabela 1a: \\(\\#\\ Patterns\\)\n\n\n\n\nTabela 1: Número de padrões encontrados pelos algoritmos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(Dataset\\)\n\\(\\#\\ rows\\)\n\\(\\#\\ cols\\)\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\nDNA\n\\(2458\\)\n\\(391\\)\n\\(134\\)\n\\(131\\)\n\\(345\\)\n\\(281\\)\n\n\nAccidents\n\\(340183\\)\n\\(468\\)\n\\(133\\)\n\\(78\\)\n\\(215\\)\n\\(12261\\)\n\n\nInstacart\n\\(2704831\\)\n\\(1235\\)\n\\(n/a\\)\n\\(328\\)\n\\(712\\)\n\\(8119\\)\n\n\nKosarak\n\\(990002\\)\n\\(41270\\)\n\\(n/a\\)\n\\(302\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\nGenomes\n\\(2504\\)\n\\(226623\\)\n\\(n/a\\)\n\\(42\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\n\n\n\n\n\nTabela 1b: \\(Runtime\\)\n\n\n\n\nTabela 2: Comparativo de tempo entre os algoritmos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(Dataset\\)\n\\(\\#\\ rows\\)\n\\(\\#\\ cols\\)\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\nDNA\n\\(2458\\)\n\\(391\\)\n\\(4 m\\)\n\\(26 s\\)\n\\(20 s\\)\n\\(2 s\\)\n\n\nAccidents\n\\(340183\\)\n\\(468\\)\n\\(12 h\\)\n\\(6 m\\)\n\\(14 m\\)\n\\(21 h\\)\n\n\nInstacart\n\\(2704831\\)\n\\(1235\\)\n\\(\\infty\\)\n\\(44 m\\)\n\\(25 m\\)\n\\(8 h\\)\n\n\nKosarak\n\\(990002\\)\n\\(41270\\)\n\\(\\infty\\)\n\\(5 h\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\nGenomes\n\\(2504\\)\n\\(226623\\)\n\\(\\infty\\)\n\\(9 m\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\n\n\n\n\n\n\n\n\nTabela 3: Tabela comparativa dos datasets\n\n\n\n\n\n\n\n(a) Linhas e colunas dos datasets\n\n\n\n\n\n\\(Dataset\\)\n\\(\\#\\ rows\\)\n\\(\\#\\ cols\\)\n\n\n\n\nDNA\n\\(2458\\)\n\\(391\\)\n\n\nAccidents\n\\(340183\\)\n\\(468\\)\n\n\nInstacart\n\\(2704831\\)\n\\(1235\\)\n\n\nKosarak\n\\(990002\\)\n\\(41270\\)\n\n\nGenomes\n\\(2504\\)\n\\(226623\\)\n\n\n\n\n\n\n\n\n\n\n\n(b) Número de padrões encontrados pelos algoritmos\n\n\n\n\n\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\n\\(134\\)\n\\(131\\)\n\\(345\\)\n\\(281\\)\n\n\n\\(133\\)\n\\(78\\)\n\\(215\\)\n\\(12261\\)\n\n\n\\(n/a\\)\n\\(328\\)\n\\(712\\)\n\\(8119\\)\n\n\n\\(n/a\\)\n\\(302\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\n\\(n/a\\)\n\\(42\\)\n\\(n/a\\)\n\\(n/a\\)\n\n\n\n\n\n\n\n\n\n\n\n(c) Comparativo de tempo entre os algoritmos\n\n\n\n\n\n\\(Asso\\)\n\\(BinaPs\\)\n\\(Desc\\)\n\\(Slim\\)\n\n\n\n\n\\(4 m\\)\n\\(26 s\\)\n\\(20 s\\)\n\\(2 s\\)\n\n\n\\(12 h\\)\n\\(6 m\\)\n\\(14 m\\)\n\\(21 h\\)\n\n\n\\(\\infty\\)\n\\(44 m\\)\n\\(25 m\\)\n\\(8 h\\)\n\n\n\\(\\infty\\)\n\\(5 h\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\n\\(\\infty\\)\n\\(9 m\\)\n\\(\\infty\\)\n\\(\\infty\\)\n\n\n\n\n\n\n\n\n\n\n\n\nEm alguns casos, os outros algoritmos não conseguiram rodar em até 3 dias ou dentre 256GB de RAM. Tais cenários foram marcados com n/a ou infinito ({Tabela 2}).\nO BinaPs retornou resultados menos redundantes, facilitando interpretabilidade. Além disso, foram notados algumas falhas em outros algoritmos, dentre eles:\n\nAsso não conseguiu escalar bem\nSlim encontrou milhares de resultados redundantes\nDesc sofre de underfitting e só retornou padrões de tamanho 2 no Instacart.\n\n\n\n\nFoi feita uma análise quantitativa em 3 dos bancos de dados listados acima. Duas comparativas (DNA, Instacart) e uma individual.\nDNA: BinaPs e Asso encontraram blocos de DNA e conjuntos desses blocos como estruturas, representando elementos biologicamente relevantes. Slim começa a encontrar blocos, mas faz um overfitting para padrões grandes demais que acontecem raramente e não tem estrutura evidente de blocos. Desc encontra padrões pequenos apenas graças a um underfitting.\nInstacart: BinaPs encontra padrões grandes com combinações arbitrárias como um conjunto de 12 frutas comprados de formas diferentes. O Slim quebra este conjunto em milhares de padrões menores. Desc faz underfitting novamente, encontrando padrões de tamanho 2 apenas. Além disso, o BinaPs também encontrou padrões pequenos que se assemelham à lista de ingredientes de pratos culinários, mostrando relevância novamente.\nGenomes: De acordo com os autores, esta seção obteve os resultados mais promissores, sendo um motivador principal para o estudo.\nFoi possível encontrar padrões antes conhecidos de genes relacionados, como os NUCB2 e ABCC8 relacionados à diabetes tipo 2 e pressão alta em populações japonesas. Porém, muitas vezes esses grupos conhecidos estavam adjuntos a outros elementos, como o NCR3LG1 e ROMO1. Isso demonstra a possibilidade do uso do algoritmo para estabelecer relações novas que podem ser estudadas no futuro.\nOutro exemplo foi o dos genes SF3A1, RRP7A e Z82190 onde os dois primeiros codificam proteínas que são parte do ribossomo (que por sua conta é a fábrica de proteínas da célula), já o terceiro não é caracterizado. O padrão destes juntos é uma dica que pode guiar estudos futuros nessa área.\nPor final, ao analisar padrões de variantes entre alelos, o BinaPs sugere que variantes raras normalmente acompanhadas de comuns podem acontecer de um para o outro “\\(0 \\mid 1\\)” como na literatura, mas muitas vezes também acontece em “1 ”, ou seja, os raros no alelo que antes havia comuns e vice-versa. Os autores não sabem se isso têm significado biológico, sugerindo que isso seja analisado por profissionais da área."
  },
  {
    "objectID": "seminario1/artigo1.html#execução",
    "href": "seminario1/artigo1.html#execução",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "O artigo nos entrega um Link para o repositório. Para rodar o BinaPs em uma máquina comum é necessário:\n\n\n\nBaixar e descompactar os arquivos\nInstalar as dependências (Pytorch, Scipy, Pandas, Numpy, R)\nAlterar arquivo genSynth.sh para parâmetros de uma máquina convencional (8 a 32GB de RAM)\nExecutar ./genSynth.sh\n\nO resultado é um arquivo .dat com os dados em formato de matriz binária esparsa. Ou seja, para cada linha, os elementos da linha são os indices das posições com valor 1 na matriz original.\n\n\nPara executar basta chamar python main.py --input &lt;arquivo.dat&gt; --batch_size &lt;32 ou 64&gt; que pode também ser adjunto dos parâmetros apresentados na Tabela 4.\n\n\n\nTabela 4: Parâmetros do BinaPs\n\n\n\n\n\n\n\n\n\n\n\nParâmetro\nTipo\nValor padrão\nDescrição\n\n\n\n\n--save_model\nbool\n\\(False\\)\nSe ativado, salva o modelo treinado para disco\n\n\n--gamma\nfloat\n\\(0.1\\)\nFator de decaimento do learning rate (usado no agendador de LR)\n\n\n--lr\nfloat\n\\(0.01\\)\nTaxa de aprendizado (learning rate)\n\n\n--train_set_size\nfloat\n\\(0.9\\)\nProporção dos dados usada para treinamento\n\n\n--weight_decay\nfloat\n\\(0.0\\)\nFator de penalização L2 (regularização dos pesos)\n\n\n--batch_size\nint\n\\(64\\)\nTamanho do batch para treinamento\n\n\n--epochs\nint\n\\(10\\)\nNúmero de épocas de treinamento\n\n\n--hidden_dim\nint\n\\(-1\\)\nNúmero de neurônios ocultos (usa #features se -1)\n\n\n--log_interval\nint\n\\(10\\)\nIntervalo (em batches) para exibir logs de treino\n\n\n--seed\nint\n\\(1\\)\nSemente para reprodutibilidade (random seed)\n\n\n--test_batch_size\nint\n\\(64\\)\nTamanho do batch para teste\n\n\n--thread_num\nint\n\\(16\\)\nNúmero de threads a serem usadas no treinamento\n\n\n--input (-i)\nstr\nObrigatório\nCaminho para o arquivo de entrada (dados usados para treino e teste)\n\n\n\n\n\n\n\n\n\nApós o treinamento marcado pelas “Epoch” temos alguns dados como a “Average loss” e a “Accuracy” seguido dos padrões dispostos na Figura 6.\n\n\n\nFigura 6: Resultado da execução do BinaPs\n\n\n\n\n\n\nCada linha dos padrões mostra um padrão que foi reconstruído, como por exemplo o \\([45, 46, 47, 48, 49]\\) seguido de dois números: O primeiro o número de amostras que ativaram todos os bits e o segundo amostras que ativaram metade dos bits do padrão. Ou seja, \\(4404\\) vezes os bits \\(45\\) a \\(49\\) foram completamente ativados e \\(4425\\) vezes parcialmente ativados (metade).\nConclusão: O padrão \\([45-49]\\) é altamente confiável pois aparece em mais de 99% das vezes que é parcialmente ativado, indicando forte consistência local nos dados."
  },
  {
    "objectID": "seminario1/artigo1.html#impacto-social",
    "href": "seminario1/artigo1.html#impacto-social",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "O método do BinaPs é significativamente mais interpretável que outras soluções usando inteligência artificial ou caixas-pretas. Tal transparência entrega um grau de confiança maior aos resultados e pode levar a estudos e entendimentos novos relacionados à area investigada.\nAlém disso, como o processo é transparente, ele se torna mais fácil de ser ajustado por profissionais para evitar vieses indesejados como os de cor, gênero, raça, classe e outros."
  },
  {
    "objectID": "seminario1/artigo1.html#cenários-de-uso",
    "href": "seminario1/artigo1.html#cenários-de-uso",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "Similarmente a outros métodos de mineração de padrões, os usos são bem vastos, mas dessa vez eles são beneficiados também pela transparência. Aqui estão alguns deles:\n\nSaúde\n\nEstudo de biomarcadores relevantes para diagnósticos\nDetecção de padrões comuns à doenças como sintomas\n\nCidades inteligentes\n\nAnálise de padrões de tráfego para otimização do transporte\nMineração de padrões no uso de serviços públicos\n\nEducação\n\nAnálise de trajetórias acadêmicas para politicas de incentivo\nEstudo de consumo de cursos para personalização de trilhas\n\nComércio\n\nPadrões de compras para sistemas de recomendação\nPerfis de consumidores para marketing personalizado\n\nGovernos e Organizações\n\nDetecção de padrões de fraude em transações como as bancárias\nEstudo de padrões comportamentais para prevenção de crimes"
  },
  {
    "objectID": "seminario1/artigo1.html#riscos",
    "href": "seminario1/artigo1.html#riscos",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "O BinaPs é uma ferramenta. Da mesma forma que é necessário cuidado ao usar um martelo, é importante saber os riscos que tomamos ao usar uma ferramenta dessas para evitar problemas. Um dos maiores riscos são os de dados enviesados.\nGrande porção dos dados usados são daqueles que mais coletam dados, que tendem a ser países de primeiro mundo nas classes media e alta. Além disso, muitos dados são enviesados por cor, raça, gênero e outros fatores que não devem serem analisados como causalidade por motivos éticos.\nExemplos de dados enviesados incluem a ferramenta de triagem de currículos da Amazon, que aprendeu e manteve o preconceito de gênero que estava presente antes de sua implementação, o que desfavoreceu o gênero feminino.\nAlém disso, há áreas de implementação que não podem ter vieses como por exemplo:\n\nConcessão de crédito\n\nDiscriminação, Desinformação, Privacidade, Over-Marketing\n\nPrecificação de seguros e planos de saúde\n\nDiferenciação de grupos por fatores pessoais, étnicos, etários ou de doenças.\n\n\nEm ambos os casos, são necessárias políticas como a LGPD para garantir a anonimização dos dados e a publicação de métodos e entradas utilizados para que especialistas possam discutir as questões éticas do uso dos dados específicos utilizados."
  },
  {
    "objectID": "seminario1/artigo1.html#conclusão",
    "href": "seminario1/artigo1.html#conclusão",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "O BinaPs é um algoritmo de mineração de padrões inovador, com características transparentes e eficientes em relação à competição. Seu código é aberto e bem explicado com um gerador de dados sintéticos incluso e alguns estudos preliminares de áreas que podem beneficiar do seu uso. Se for usado como uma ferramenta de forma responsável, ele pode ser um pioneiro em estudos, análises e sumarizações de dados massivos."
  },
  {
    "objectID": "seminario1/artigo1.html#links-de-interesse",
    "href": "seminario1/artigo1.html#links-de-interesse",
    "title": "Artigo 1: Differentiable Pattern Set Mining",
    "section": "",
    "text": "Título: Differentiable Pattern Set Mining\nArtigo (Fischer e Vreeken (2021))\n\nPDF\nApresentação dos Autores\n\nApresentação\n\nPDF"
  },
  {
    "objectID": "seminario2.html",
    "href": "seminario2.html",
    "title": "Introdução",
    "section": "",
    "text": "Os seminários da disciplina consistem em uma apresentação coletiva (da turma) de um artigo mais recente sobre tópicos diretamente relacionados ao conteúdo visto em sala. A ideia é que a turma como um todo estude os artigos mais recentes da área e discuta esses trabalhos em sala. Em cada sessão, discutimos dois artigos recentes relacionados aos tópicos abordados nas aulas teóricas.\nPara isso, adotamos um formato adaptado da proposta apresentada pelos Profs. Alec Jacobson e Colin Raffel, ambos da Universidade de Toronto (Canadá) – veja aqui a proposta original. A proposta consiste em fazer uma encenação de papéis (role play) científicos para a apresentação do seminário. Nessa proposta, cada grupo cumprirá um papel na apresentação. Ao final, uma apresentação em formato de slides e um documento textual são produzidos. A apresentação é usada em sala de aula para fomentar as discussões, enquanto o documento fornece uma descrição textual das impressões da turma com a intenção de descrever o tema do artigo para um público amplo interessado em aprendizado de máquina e mineração de dados.\nSão apresentados a seguir os artigos discutidos no semestre 2025/1, com os respectivos links para os slides e documentos textuais apresentando os artigos.\n\n\n\nFinding interpretable class-specific patterns through efficient neural search\nAutores: N. P. Walter; J. Fischer; J. Vreeken. 2024\nDOI: 10.1609/aaai.v38i8.28756\n\n\n\n\n\nLocal Subgroup Discovery on Attributed Network Graphs\nAutores: C. V. Heinrich; T. Lombarts; J. Mallens; L. Tortike; D. Wolf; W. Duivesteijn. 2025\nDOI: 10.1007/978-3-031-91398-3_15"
  },
  {
    "objectID": "seminario2.html#artigo-3seminario_art3",
    "href": "seminario2.html#artigo-3seminario_art3",
    "title": "Introdução",
    "section": "",
    "text": "Finding interpretable class-specific patterns through efficient neural search\nAutores: N. P. Walter; J. Fischer; J. Vreeken. 2024\nDOI: 10.1609/aaai.v38i8.28756"
  },
  {
    "objectID": "seminario2.html#artigo-4seminario_art4",
    "href": "seminario2.html#artigo-4seminario_art4",
    "title": "Introdução",
    "section": "",
    "text": "Local Subgroup Discovery on Attributed Network Graphs\nAutores: C. V. Heinrich; T. Lombarts; J. Mallens; L. Tortike; D. Wolf; W. Duivesteijn. 2025\nDOI: 10.1007/978-3-031-91398-3_15"
  }
]